env int user_key = 2;
env int user_door = 3; 

env int DOOR_DELAY = 2;
env int USER_DELAY = 10;
env int BREAKIN_DELAY = 20;

reactiveclass Controller(10) {
    knownrebecs {
        Door door;
        User user;
    }
    statevars {
        boolean armed; 
        boolean alarm; 
        boolean door_open;

        //authentication variables 
        boolean auth_key;
        boolean key_valid;
        int valid_key; 
        int valid_code;
        int attemps; 
    }

    Controller(int key, int code) {
        armed = false;
        alarm = false;
        door_open = false;
        key_valid = false;

        auth_key = false;
        valid_key = key;
        valid_code = code; 
        attemps = 0;
    }

    msgsrv checkKey(int key) {
        if(key == valid_key) {
            auth_key = true; 
            self.setKeyValid();
        } else {
            auth_key = false; 
        }

        user.keyChecked(auth_key);
    }

    msgsrv checkCode(int code) {
        boolean valid = false; 

        if(auth_key && code == valid_code) {
            self.lockedUser();
            valid = true; 
        }

        auth_key = false;
        user.codeChecked(valid);
    }

    msgsrv lockedUser() {
        boolean internal_armed = !armed;   

        if (alarm) {
            alarm = false;
        }  

        if (internal_armed) {
            self.setArmed();
        } else {
            self.setUnarmed();
        }
    }

    msgsrv setKeyValid() {
        key_valid = true;
        delay(10);
        self.setKeyInvalid();
    }

    msgsrv setKeyInvalid() {
        key_valid = false;
    }

    msgsrv setArmed() {
        if (!door_open) {
            armed = true;
            door.lockDoor();
        }
    }

    msgsrv setUnarmed() {
        armed = false;
        door.unlockDoor();
    }

    msgsrv doorOpened() {
        door_open = true;

        if (armed) {
            self.alarma();
        }
    }

    msgsrv doorClosed() {
        door_open = false;
    }

    msgsrv alarma() {
        alarm = true;
    }
}

reactiveclass Door(5) {
    knownrebecs {
        Controller controller;
        BadActor intruder;
    }
    
    statevars {
        boolean isLocked;
        boolean isOpen;
    }

    Door() {
        isOpen = false; 
        isLocked = false; 
    }

    msgsrv openDoor() {
        if (!isLocked && !isOpen){
            isOpen = true; 
            controller.doorOpened() after(DOOR_DELAY);
        }
    }

    msgsrv closeDoor() {
        if (isOpen) {
            isOpen = false;
            controller.doorClosed() after(DOOR_DELAY);
        }
    }

    msgsrv lockDoor() {
        if (!isOpen){
            isLocked = true;
            intruder.breakIn() after(DOOR_DELAY / 2); // Door can't be trusted
        }
    }

    msgsrv unlockDoor() {
        isLocked = false; 
    }

    msgsrv breakDoor() {
        isOpen = true;
        isLocked = false;
        controller.doorOpened();
    }
}

reactiveclass BadActor(5) {
    knownrebecs {
        Door door;
    }

    statevars { }

    msgsrv breakIn() {
        boolean conscience = ?(true, false);
        if (!conscience) {
            door.breakDoor();
        }
    }
}

reactiveclass User(5) {
    knownrebecs {
        Controller controller; 
        Door door;
    }

    statevars {
        int key, code;
        boolean locked;
        int user_delay;
    }

    User(int k, int c) {
        key = k;
        code = c;
        locked = false;
        user_delay = 0;

		self.start();
    }
    
    msgsrv start(){
        boolean path = ?(true, false);

        if (path){
            self.openDoor();
        } else {
            self.enterKey();
        }    	
    }

    msgsrv enterKey() {
        controller.checkKey(key) after(USER_DELAY);
    }

    msgsrv keyChecked(boolean valid) {
        if (valid) {
            controller.checkCode(code) after(USER_DELAY);
        } else {
            self.enterKey();
        }
    }

    msgsrv codeChecked(boolean valid) {
        if (valid) {
            locked = !locked;
        }

        self.start() after(USER_DELAY);
    }

    msgsrv setStatus(boolean status) {
        locked = status;
    }

    msgsrv openDoor() {
        if (!locked) {
            door.openDoor();
            door.closeDoor() after(DOOR_DELAY + 1);
        }

        self.start() after(USER_DELAY);
    }
}

main {
    User user(controller, door): (user_key, user_door);
    Controller controller(door, user):(user_key, user_door);
    BadActor intruder(door): ();
    Door door(controller, intruder):();
}